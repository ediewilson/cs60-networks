# Lab 2, Chatroom
## Elizabeth Wilson, 20S, COSC 60
### Overview
The code is written in Java, and can be compiled and run on VSCode with the Java extension pack
### Questions 
1. First run the client. You will recieve a prompt from the server that asks for a username, to which you can enter any username you'd like. Then, you are free to chat, and will constantly be recieving messages from other clients, prefixed by their username, from the server. To end the connection, ternminate the program or type `quit`. If any other client ends their connection, you will recieve message `<username> has left the chat`. If the server ends its connection. You will recieve message `Server has hung up` indicating that the chat is ended.
2. The client is programmed using the java classes Scanner, Socket, PrintWriter, and BufferedReader. It uses a socket to connect to a localhost port, then initializes output and input readers. After this, it displays to the user that it has connected to the chatroom. It uses a handleUser method to read the inputs, and includes a ServerHandler private class to recieve broadcasts of other messages.
3. The server can be used either by a chatroom moderator or run and left alone. The server is started, and then always open for connections. The server outputs `new user in the chat` when clients join, following up with `It's <username>` when it recieves the username from the user. This happens whenever a new client joins. It also broadcasts `<username> entered the room` when someone enters to all of the current users. The server has `<username> hung up` messages when someone leaves, and broadcasts a `Server hung up` message to all users when it stops. Mainly, the server is used to accept connections and moderate/host the chat
4. The server programming is similar to the client. In the server program, there is a ClientHandler class as well as the Server class. The client hanlder class takes a Socket and the Server class to handle clients. When a client joins, it is accepted by the socket, and added to the array. The Server works by opening a communication channel with a PrintWriter for output and a BufferedReader for input. It uses the PrintWriter class to ask the client for username, and to welcome clients to the chat. Then, while there are incoming chats, it prints them to the local console and in the chat room. It uses an array of the ClientHandlers, one handler for each client. It uses synchronized methods to handle the adding, removing, and broadcasting, meaning that the methods can only be accessed by one ClientHandler at a time. This is what prevents interuptions in UI as well as server functionality when clients are trying to do the same thing at the same time. This allows the clients to type simultaneously, as it is in a constant communitcation loop. The broadcast method ensures that the client who sent the message won't recieve it again. 
5.  
- The client and server can be run on the java extension of VSCode, which it will prompt you to download once you open the code in it. 
- First, run the server
- Then, open up a few clients, entering usernames for all of them
- Enter different usernames for all of the clients, and send some messages to see the usernames pop up for each client. The server will show the whole chat room, with all messages coming from the different clients. 
- To test the quiting, type quit for one or more of the clients 
6. When a user connects to the server, they are prompted for a username. They enter a username and everyone in the chat is alerted by the server that the user has joined the chat. When a client sends message, the `<username>: message` will show and send to others. The message will not be resent to the client who sent it. The client can exit the chat by typing `quit`, after which the client who quit will recieve confirmation that they quit and the rest of the room will see `<username> hung up.`. The server hangs up by stopping the server program, and broadcasts the message `Server hung up`. The protocol that we worked on was a variation off of protocol 9 which we initially designed. 
7. At first, we looked at using protocol 2 on the wiki but it had a lot of complex error messages and also didn't seem to be super user friendly. We wanted to use a protocol that would simulate a real online chat platform. We designed protocol 9 for user simplicity. However, in the process of writing the actual chatroom the decision was made by us to prompt the client to create their own username upon entry and to make quitting the server a process of actually ending it, rather than typing quit. Treating the server as a platform for chatting rather it having the same process to quit as the client is another way that I deviated from the protocol. 
8. The server talks to multiple clients using multiple threads. Each client connects to its own socket and communicates with that. The server uses the ClientHandler class to handle the individual clients incoming messages, and also to broadcast to them. The synchronized methods make sure that there is no overlap by the client handlers in sending their communications.
9. Multiple clients can talk at the same time becasue of the way the client handlers use synchronization to feed the messages from the clients into the server. Since there is a different thread for each client, no client ever has a monopoly of the reading and writing processes. 
10. A log on is handled by the client reaching out, and when the connection is accepted they are added by the server to the array of client handlers. The server then broadcasts that the client has entered the room to everyone else who is chatting. When the client quits the room, their client handler is removed from the array and a message is broadcasted to everyone else. Alternatively, if they dont `quit` but their program is terminated, it is treated the same as if they were to hang up. 
11. My client connects to the other student's server as long as the ports are set to the same thing. The functionality is the same except for the quit functionality of their server. My partners server can type quit to quit, while mine does not. 
12. The other student's client requires you to input a port number, but once it is connected the client can be used with my server in the same way as mine.  
13. The differences in implimentation are that the other student's server can type quit to end the room, whereas mine ends the room by ending the program. Besides that, the protocol implimentation is very similar. 
